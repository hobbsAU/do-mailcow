#!/usr/bin/env bash
# A menu driven shell script to provision mailcow on DigitalOcean

#Set Bash sctrict modes
set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t'


## ----------------------------------
# Section: Define variables
# ----------------------------------
DEBUG=1
DO_BIN=/usr/bin/doctl
ENV_CONF=${1:-env.conf}
RED='\033[0;41;30m'
STD='\033[0;0;39m'
#[ -z "${ENV_CONF:-}" ] && ENV_CONF='env.conf'
echo $ENV_CONF
WAN_IP=$(dig @resolver1.opendns.com ANY myip.opendns.com +short)


# ----------------------------------
#  Section: User defined functions
# ----------------------------------
function read_env_conf {
if [ -f ${ENV_CONF} ]; then
    echo "Reading user config...." >&2

    # check if the file contains something we don't want
    CONFIG_SYNTAX="(^\s*#|^\s*$|^\s*[a-z_][^[:space:]]*=[^;&\(\`]*$)"
    if egrep -q -iv "$CONFIG_SYNTAX" "$ENV_CONF"; then
      echo "Config file is unclean, please check it..." >&2
      exit 1
    fi
    # now source it, either the original or the filtered variant
    # export $(cat $ENV_CONF | grep -v ^\# | xargs)
    source "$ENV_CONF"
else
    echo "There is no configuration file call ${ENV_CONF}"
    pause
fi

#Must have access token and hostname    
if [[ ! ${#DIGITALOCEAN_ACCESS_TOKEN} == 64 ]]; then
  while [[ ! ${#DIGITALOCEAN_ACCESS_TOKEN} == 64 ]]; do
    read -ep "DigitalOcean API Token (must be generated via DigitalOcean control panel): " DIGITALOCEAN_ACCESS_TOKEN
  done
fi

#Export Access Token for doctl authentication
export DIGITALOCEAN_ACCESS_TOKEN=$DIGITALOCEAN_ACCESS_TOKEN

if [ -z "$DROPLET_HOSTNAME" ]; then
	while [ -z "$DROPLET_HOSTNAME" ]; do
        	list_droplet 
        	read -ep "Name: " DIGITALOCEAN_HOSTNAME
        done
fi

}

function pause {
  read -p "Press [Enter] key to continue..." fackEnterKey
}


function log {
	local now=$(date +'%Y-%m-%d %H:%M:%S')
	echo "[$now] $1"
}

function create_droplet {
local   PARMS="compute droplet create $1 --wait --size $2 --image $3 --region $4 --ssh-keys $5 --tag-names $6"

	if [ ! -z "$DROPLET_USERDATAFILE" ]; then
		PARMS+=(--user-data-file $DROPLET_USERDATAFILE)
	fi

	if [ ! -z "$DROPLET_MONITORING" ] && [ $DROPLET_MONITORING = "true" ] ; then
		PARMS+=(--enable-monitoring)
	fi

        if [ $DEBUG -eq "1" ]; then
                echo "${PARMS[@]}";
                eval "printenv |grep DIGITAL";
        fi

	eval "$DO_BIN ${PARMS[@]}"
	
	$DO_BIN compute domain records update email.hob.bs --record-ttl 60 --record-name mail1 --record-id 59435401 --record-data $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $3 }')

}

function delete_droplet {
	$DO_BIN compute droplet-action power-off --wait "$1"
	$DO_BIN compute droplet delete --force "$1"
}

function get_droplet {
	$DO_BIN compute droplet get "$1"
}

function list_droplet {
	$DO_BIN compute droplet list
}

function create_volume {
    doctl compute volume create "$1" --region "$2" --size "$3" --desc "Volume for $1"
}


function attach_volume {
local droplet_id=""
local volume_id=""
local mnt_dir=""
mnt_dir=$(echo "$DROPLET_TAG-vol" | sed -e 's/-/_/g')	

	#Check for droplet and volume
	droplet_id=$($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }') || { log "Droplet must exist"; return 0; }
	volume_id=$($DO_BIN compute volume list | grep "$DROPLET_TAG-vol" | awk '{ print $1 }') || { log "Volume must exist"; return 0; }

	#Check droplet is on
	[[ $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $11 }') == "active" ]] || { log "Droplet must be powered on"; return 0; }
	
	#Attach volume	
	if [ ! -z $droplet_id ] && [ ! -z $volume_id ]; then
		log "Attaching Volume: $volume_id to Droplet: $droplet_id"
        	$DO_BIN compute volume-action attach $volume_id $droplet_id && log "Volume successfully attached" || { log "Problem attaching volume!"; return 0; }
        	log "Rebooting Droplet for changes to take effect.."
		$DO_BIN compute droplet-action reboot --wait $droplet_id;
		#execute_command $droplet_id "sudo mkdir -p /mnt/$mnt_dir && sudo grep -q -F '/dev/disk/by-id/scsi-0DO_Volume_$DROPLET_TAG-vol /mnt/$mnt_dir ext4 defaults,noatime,nofail,discard 0 0' /etc/fstab || echo '/dev/disk/by-id/scsi-0DO_Volume_$DROPLET_TAG-vol /mnt/$mnt_dir ext4 defaults,noatime,nofail,discard 0 0' | sudo tee -a /etc/fstab" || log "SSH not running try again later";
		#execute_command $droplet_id "sudo mount -a" && log "Volume successfully mounted" || log "Error mounting volume!";
		#execute_command $droplet_id "sudo mkdir -p /mnt/$DROPLET_TAG-vol"
		#execute_command $droplet_id "sudo mkdir -p /mnt/$DROPLET_TAG-vol sudo mount -a"
	else
		log "Droplet and Volume must exist!"
	fi

}


function detach_volume {
local droplet_id=""
local volume_id=""
	#Detach volume
	droplet_id=$($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }');
	volume_id=$($DO_BIN compute volume list | grep "$DROPLET_TAG-vol" | awk '{ print $1 }');
        if [ ! -z $droplet_id ] && [ ! -z $volume_id ]; then
		log "Detaching Volume: $volume_id from Droplet: $droplet_id"
        	$DO_BIN compute droplet-action power-off --wait $droplet_id;
        	$DO_BIN compute volume-action detach $volume_id $droplet_id;
        	$DO_BIN compute droplet-action power-on --wait $droplet_id;
	else
		log "Droplet and Volume must exist!"
	fi
}

function create_volume {
$DO_BIN compute volume create $DROPLET_TAG-vol --fs-type ext4 --region $DROPLET_REGION --size 10GiB
}


function attach_floatingip {
	droplet_id=$($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }');
        if [ ! -z $droplet_id ] && [ ! -z $NETWORK_FLOATINGIP ]; then
		log "Attaching floating IP: $NETWORK_FLOATINGIP to Droplet: $droplet_id"
        	$DO_BIN compute floating-ip-action assign $NETWORK_FLOATINGIP $droplet_id;
	else
		log "Droplet and Floating IP must exist!"
	fi
	
}

function execute_command {
	log "Executing \""$2"\" on $1"
	trap - SIGINT
	$DO_BIN compute ssh "$1" --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH --ssh-command "$2"
	trap ' ' SIGINT
}

function show_help {
echo "Usage: "
}

function update_firewall {
local firewall_id=""

	#Check for firewall
	firewall_id=$($DO_BIN compute firewall list | grep "$NETWORK_FIREWALL" | awk '{ print $1 }') || { log "Firewall must exist"; return 0; }
	log "Updating Firewall.."
	$DO_BIN compute firewall update $firewall_id --inbound-rules "protocol:tcp,ports:25,address:0.0.0.0/0 protocol:tcp,ports:80,address:$WAN_IP/32 protocol:tcp,ports:110,address:0.0.0.0/0 protocol:tcp,ports:143,address:0.0.0.0/0 protocol:tcp,ports:443,address:$WAN_IP/32 protocol:tcp,ports:465,address:0.0.0.0/0 protocol:tcp,ports:587,address:0.0.0.0/0 protocol:tcp,ports:993,address:0.0.0.0/0 protocol:tcp,ports:995,address:0.0.0.0/0 protocol:tcp,ports:2222,address:0.0.0.0/0 protocol:tcp,ports:4190,address:0.0.0.0/0" --name mailcow-prod-fw
}

function attach_firewall {
local droplet_id=""
local firewall_id=""

	#Check for firewall
	droplet_id=$($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }') || { log "Droplet must exist"; return 0; }
	firewall_id=$($DO_BIN compute firewall list | grep "$NETWORK_FIREWALL" | awk '{ print $1 }') || { log "Firewall must exist"; return 0; }

	 $DO_BIN compute firewall add-droplets $firewall_id --droplet-ids $droplet_id
}

#Install Mailcow
function mailcow_install {
local root_dir=""
root_dir=$(echo "$DROPLET_TAG-vol" | sed -e 's/-/_/g')	

	execute_command $DROPLET_HOSTNAME 'sudo bash -s' <<EOF
		export MAILCOW_HOSTNAME=$DROPLET_HOSTNAME
		export MAILCOW_TZ=$MAILCOW_TZ
		umask 0022
		whoami && umask
		rm -rf /opt/mailcow*
		cd /opt
		git clone https://github.com/mailcow/mailcow-dockerized
		cd mailcow-dockerized
		./generate_config.sh
		echo '{  "data-root": "/mnt/$root_dir/docker" }' | sudo tee /etc/docker/daemon.json
		sudo systemctl restart docker
		exit 0
EOF
}

function mailcow_start {
	#$DO_BIN compute ssh $DROPLET_HOSTNAME --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH --ssh-command 'sudo bash -s' <<EOF
	execute_command $DROPLET_HOSTNAME 'sudo bash -s' <<EOF
        cd /opt/mailcow-dockerized/
	pwd
	docker-compose pull
	docker-compose up -d
EOF
}


function menu_droplet {
local choice=""
local droplet_id=""
local volume_id=""

while [ "$choice" != x ]; do 
        clear
        echo "~~~~~~~~~~~~~~~~~~~~~~~~~"        
        echo " D R O P L E T - M E N U"
        echo "~~~~~~~~~~~~~~~~~~~~~~~~~"
        echo "1.  Create Droplet 		- Create and configure mailcow Droplet"
        echo "2.  Destroy Droplet 		- Destroy mailcow Droplet"
        echo "3.  List Droplets		- List Droplets"
        echo "4.  Attach Volume		- Attach Volume to Droplet"
        echo "5.  Detach Volume		- Remove Volume from Droplet"
        echo "6.  Attach Floating IP		- Attach Floating IP to Droplet"
        echo "7.  Reboot Droplet 		- Power on Droplet"
        echo "8.  Create Volume		- Create 10G Volume"
        echo "9.  SSH to Droplet   		- SSH to Droplet"
        echo "x.  Exit"
        echo ""
        read -p "Enter choice [ 0 - 11 ] " choice
        case $choice in
                1) 
			#Check if droplet exists with same tag
			if [[ -z $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }') ]]; then
				#Create Droplet
				log "Creating Droplet: $DROPLET_HOSTNAME in $DROPLET_REGION tagged with $DROPLET_TAG";
				create_droplet "$DROPLET_HOSTNAME" "$DROPLET_SIZE" "$DROPLET_IMAGE" "$DROPLET_REGION" "$DROPLET_SSHKEY" "$DROPLET_TAG";
			else
				log "ERROR: Droplet already exists";
			fi
			pause ;;
                2) 
			#Find and delete all Droplets with specific tag
			for droplet_id in $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }'); do
	            		#[ -z $($DO_BIN compute list | grep "$DROPLET_TAG" | awk -F $'[[:space:]][[:space:]][[:space:]]+' '{ print $12 }') ] && echo "No Volumes" || $DO_BIN compute
				log "Deleting Droplet $droplet_id";
 				delete_droplet "$droplet_id";
			done;
			pause ;;
                3) 
			log "Listing all Droplets"
			list_droplet
			pause ;;
                4) 
			log "Attaching volume.."
			attach_volume
			pause ;;
                5) 
			log "Detaching volume.."
			detach_volume
			pause ;;
                6) 
			log "Attaching Floating IP.."
			attach_floatingip
			pause ;;
		7)	$DO_BIN compute droplet-action reboot --wait $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }'); pause ;;
                8) 
			log "Create volume.."
			create_volume
			pause ;;
                9) 
			log "SSH to Droplet: $DROPLET_HOSTNAME"
			$DO_BIN compute ssh $DROPLET_HOSTNAME --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH && echo "OK" || echo "Error";
			pause ;;
                x) return 0;;
                *) echo -e "${RED}Error...${STD}" && sleep 1
        esac
done
}



function menu_mailcow {
local choice=""

while [ "$choice" != x ]; do 
        clear
        echo "~~~~~~~~~~~~~~~~~~~~~~~~~"        
        echo " M A I L C O W - M E N U"
        echo "~~~~~~~~~~~~~~~~~~~~~~~~~"
        echo "1.  Mailcow Install 		- Create and configure mailcow Droplet"
        echo "2.  Mailcow Start 		- Destroy mailcow Droplet"
        echo "3.  Mailcow Stop		- List Droplets"
        echo "4.  Mailcow Backup Config		- Attach Volume to Droplet"
        echo "5.  Mailcow Backup Data		- Remove Volume from Droplet"
        echo "6.  Mailcow Logs			- Remove Volume from Droplet"
        echo "x.  Exit"
        read -p "Enter choice [ 0 - 5 ] " choice
        case $choice in
                1) mailcow_install; pause ;;
                2) mailcow_start; pause ;;
                3) mailcow_stop; pause ;;
                5) pause ;;
                6) execute_command $DROPLET_HOSTNAME 'cd /opt/mailcow-dockerized/ && sudo docker-compose logs -f --tail=100'; pause ;;
                x) return 0;;
                *) echo -e "${RED}Error...${STD}" && sleep 1
        esac
done

}

# Function to display main menu
function menu_main {
local choice=""

while [ 1 ]; do 
        clear
        echo "~~~~~~~~~~~~~~~~~~~~~"    
        echo " M A I N - M E N U"
        echo "~~~~~~~~~~~~~~~~~~~~~"
        echo "1. DigitalOcean Droplet"
        echo "2. DigitalOcean Volumes"
        echo "3. DigitalOcean Network"
        echo "5. Mailcow"
        echo "x. Exit"
        read -p "Enter choice [ 0 - 5 ] " choice
        case $choice in
                1) menu_droplet ;;
                2) ;;
                3) update_firewall; attach_firewall; pause ;;
                5) menu_mailcow ;;
                x) exit 0;;
                *) echo -e "${RED}Error...${STD}" && sleep 1
        esac
done
}




# ----------------------------------------------
# Section: Trap CTRL+C, CTRL+Z and quit singles
# ----------------------------------------------
trap '' SIGINT SIGQUIT SIGTSTP

# -----------------------------------
# Section: Main logic - infinite loop
# ------------------------------------

while getopts "hd" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    d)  DEBUG=1
        ;;
        esac
done

read_env_conf
menu_main

exit 0
