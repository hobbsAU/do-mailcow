#!/usr/bin/env bash
# A menu driven shell script to provision mailcow on DigitalOcean

set -o errexit
#set -o nounset
set -o pipefail


## ----------------------------------
# Section: Define variables
# ----------------------------------
DEBUG=1
DO_BIN=/usr/bin/doctl
[ -z "$ENV_CONF" ] && ENV_CONF='env.conf'


# ----------------------------------
#  Section: User defined functions
# ----------------------------------
function read_env_conf {
if [ -f ${ENV_CONF} ]; then
    echo "Reading user config...." >&2

    # check if the file contains something we don't want
    CONFIG_SYNTAX="(^\s*#|^\s*$|^\s*[a-z_][^[:space:]]*=[^;&\(\`]*$)"
    if egrep -q -iv "$CONFIG_SYNTAX" "$ENV_CONF"; then
      echo "Config file is unclean, please check it..." >&2
      exit 1
    fi
    # now source it, either the original or the filtered variant
    export $(cat $ENV_CONF | grep -v ^\# | xargs)
    echo $MAILCOW_TZ
    #source "$ENV_CONF"
else
    echo "There is no configuration file call ${ENV_CONF}"
    pause
fi

#Must have access token and hostname    
if [[ ! ${#DIGITALOCEAN_ACCESS_TOKEN} == 64 ]]; then
  while [[ ! ${#DIGITALOCEAN_ACCESS_TOKEN} == 64 ]]; do
    read -ep "DigitalOcean API Token (must be generated via DigitalOcean control panel): " DIGITALOCEAN_ACCESS_TOKEN
  done
fi
}

function pause {
  read -p "Press [Enter] key to continue..." fackEnterKey
}


function log {
	local now=$(date +'%Y-%m-%d %H:%M:%S')
	echo "[$now] $1"
}

function create_droplet {
local   PARMS="compute droplet create $1 --wait --size $2 --image $3 --region $4 --ssh-keys $5 --tag-names $6"

	if [ ! -z "$DROPLET_USERDATAFILE" ]; then
		PARMS+=(--user-data-file $DROPLET_USERDATAFILE)
	fi

	if [ ! -z "$DROPLET_MONITORING" ] && [ $DROPLET_MONITORING = "true" ] ; then
		PARMS+=(--enable-monitoring)
	fi

        if [ $DEBUG -eq "1" ]; then
                echo "${PARMS[@]}";
                eval "printenv |grep DIGITAL";
        fi

	eval "$DO_BIN ${PARMS[@]}"

}

function delete_droplet {
	$DO_BIN compute droplet-action power-off --wait "$1"
	$DO_BIN compute droplet delete --force "$1"
}

function get_droplet {
	$DO_BIN compute droplet get "$1"
}

function list_droplet {
	$DO_BIN compute droplet list
}

function create_volume {
    doctl compute volume create "$1" --region "$2" --size "$3" --desc "Volume for $1"
}

function attach_volume_to_droplet {
    local volume=$(doctl compute volume list | grep "$1" | awk '{ print $1 }')
    local droplet=$(doctl compute droplet list | grep "$2" | awk '{ print $1 }')
    doctl compute volume-action attach "$volume" "$droplet"
}

function delete_volume {
    doctl compute volume delete "$1"
}

function execute_command {
	echo "$DO_BIN compute ssh "$1" --ssh-command "$2" --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH"
	$DO_BIN compute ssh "$1" --ssh-command "$2" --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH
}

function show_help {
echo "Usage: "
}


#Install Mailcow
function mailcow_install {
	$DO_BIN compute ssh $DROPLET_HOSTNAME --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH --ssh-command 'sudo bash -s' <<EOF
		export MAILCOW_HOSTNAME=$DROPLET_HOSTNAME
		export MAILCOW_TZ=$MAILCOW_TZ
		umask 0022
		whoami && umask
		rm -rf /opt/mailcow*
		cd /opt
		git clone https://github.com/mailcow/mailcow-dockerized
		cd mailcow-dockerized
		./generate_config.sh
		exit 0
EOF
}

function mailcow_start {
	$DO_BIN compute ssh $DROPLET_HOSTNAME --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH --ssh-command 'sudo bash -s' <<EOF
        cd /opt/mailcow-dockerized/
	pwd
	ls -al
	docker-compose pull
	docker-compose up -d
EOF
}


function show_menu_droplet {
        clear
        echo "~~~~~~~~~~~~~~~~~~~~~~~~~"        
        echo " D R O P L E T - M E N U"
        echo "~~~~~~~~~~~~~~~~~~~~~~~~~"
        echo "1.  Create Droplet 	- Create and configure mailcow Droplet"
        echo "2.  Destroy Droplet 	- Destroy mailcow Droplet"
        echo "3.  List Droplets		- List Droplets"
        echo "4.  Attach Volume		- Attach Volume to Droplet"
        echo "5.  Detach Volume		- Remove Volume from Droplet"
        echo "9.  SSH to Droplet   		- SSH to Droplet"
        echo "0.  Exit"
}

function read_menu_droplet {
        local choice
	local droplet_id
	local volume_id

        if [ -z "$DROPLET_HOSTNAME" ]; then
                while [ -z "$DROPLET_HOSTNAME" ]; do
                        list_droplet 
                        read -ep "Name: " DIGITALOCEAN_HOSTNAME
                done
        fi
        echo ""
        read -p "Enter choice [ 0 - 11 ] " choice
        case $choice in
                1) 
			#Check if droplet exists with same tag
			if [[ -z $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }') ]]; then
				#Create Droplet
				log "Creating Droplet: $DROPLET_HOSTNAME in $DROPLET_REGION tagged with $DROPLET_TAG";
				create_droplet "$DROPLET_HOSTNAME" "$DROPLET_SIZE" "$DROPLET_IMAGE" "$DROPLET_REGION" "$DROPLET_SSHKEY" "$DROPLET_TAG";
			else
				log "ERROR: Droplet already exists";
			fi
			pause ;;
                2) 
			#Find and delete all Droplets with specific tag
			for droplet_id in $($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }'); do
	            		#[ -z $($DO_BIN compute list | grep "$DROPLET_TAG" | awk -F $'[[:space:]][[:space:]][[:space:]]+' '{ print $12 }') ] && echo "No Volumes" || $DO_BIN compute
				log "Deleting Droplet $droplet_id";
 				delete_droplet "$droplet_id";
			done;
			pause ;;
                3) 
			log "Listing all Droplets"
			list_droplet
			pause ;;
                4) 
			#Attach volume
			droplet_id=$($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }');
			volume_id=$($DO_BIN compute volume list | grep "$VOLUME_NAME" | awk '{ print $1 }');
            			if [ ! -z $droplet_id ] && [ ! -z $volume_id ]; then
					log "Attaching Volume: $volume_id to Droplet: $droplet_id"
            				$DO_BIN compute volume-action attach $volume_id $droplet_id;
				else
					log "Droplet and Volume must exist!"
				fi
			pause ;;
                5) 
			#Detach volume
			droplet_id=$($DO_BIN compute droplet list | grep "$DROPLET_TAG" | awk '{ print $1 }');
			volume_id=$($DO_BIN compute volume list | grep "$VOLUME_NAME" | awk '{ print $1 }');
            			if [ ! -z $droplet_id ] && [ ! -z $volume_id ]; then
					log "Detaching Volume: $volume_id from Droplet: $droplet_id"
            				$DO_BIN compute droplet-action power-off $droplet_id;
            				$DO_BIN compute volume-action detach $volume_id $droplet_id;
				else
					log "Droplet and Volume must exist!"
				fi
			pause ;;
                9) 
			log "SSH to Droplet: $DROPLET_HOSTNAME"
			$DO_BIN compute ssh $DROPLET_HOSTNAME --ssh-port $DROPLET_SSH_PORT --ssh-user $DROPLET_SSH_USER --ssh-key-path $DROPLET_SSH_KEY_PATH
			pause ;;
                0) return 1;;
                *) echo -e "${RED}Error...${STD}" && sleep 1
        esac
}


function menu_droplet {
local loop_exit=0
while [ $loop_exit -eq 0 ]
do
        show_menu_droplet
        read_menu_droplet
        loop_exit=$?
done
}



# Function to display main menu
function show_menu_main {
        clear
        echo "~~~~~~~~~~~~~~~~~~~~~"    
        echo " M A I N - M E N U"
        echo "~~~~~~~~~~~~~~~~~~~~~"
        echo "1. DigitalOcean Droplet"
        echo "2. DigitalOcean Volumes"
        echo "3. DigitalOcean Network"
        echo "5. Mailcow"
        echo "0. Exit"
}

# read input from the keyboard and take a action
# invoke the one() when the user select 1 from the menu option.
# invoke the two() when the user select 2 from the menu option.
# Exit when user the user select 3 form the menu option.
function read_menu_main {
        local choice
        read -p "Enter choice [ 0 - 5 ] " choice
        case $choice in
                1) menu_droplet ;;
                2) ;;
                3) ;;
                5) mailcow_install; pause ;;
                0) exit 0;;
                *) echo -e "${RED}Error...${STD}" && sleep 1
        esac
}




# ----------------------------------------------
# Section: Trap CTRL+C, CTRL+Z and quit singles
# ----------------------------------------------
trap '' SIGINT SIGQUIT SIGTSTP

# -----------------------------------
# Section: Main logic - infinite loop
# ------------------------------------

while getopts "hd" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    d)  DEBUG=1
        ;;
        esac
done

read_env_conf
while true
do
        show_menu_main
        read_menu_main
done

